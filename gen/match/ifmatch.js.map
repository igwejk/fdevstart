{"version":3,"sources":["/projects/nodejs/botbuilder/fdevstart/src/../src/match/ifmatch.ts"],"names":[],"mappings":";AAEA,IAAkB,gBAIjB;AAJD,WAAkB,gBAAgB;IAChC,6DAAW,CAAA;IACX,uDAAI,CAAA;IACJ,yDAAK,CAAA;AACP,CAAC,EAJiB,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAIjC;AAGY,QAAA,YAAY,GAAG,UAAU,CAAC;AAC1B,QAAA,UAAU,GAAG,QAAQ,CAAC;AACtB,QAAA,QAAQ,GAAG,MAAM,CAAC;AAYlB,QAAA,cAAc,GAAG,CAAC,eAAe,EAAE,aAAa,EAAE,YAAY,EAAE,WAAW,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAkC5G,CAAC;AAOF,IAAmB,YAGlB;AAHD,WAAmB,YAAY;IAC7B,+CAAI,CAAA;IACJ,mDAAM,CAAA;AACR,CAAC,EAHkB,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAG9B;AAKI,CAAC;AAoGL,CAAC;AAoCF,IAAkB,cAGjB;AAHD,WAAkB,cAAc;IAC9B,2DAAQ,CAAA;IACR,mEAAY,CAAA;AACd,CAAC,EAHiB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAG/B","file":"match/ifmatch.js","sourcesContent":["\r\n\r\nexport const enum EnumResponseCode {\r\n  NOMATCH = 0,\r\n  EXEC,\r\n  QUERY\r\n}\r\n\r\n\r\nexport const CAT_CATEGORY = \"category\";\r\nexport const CAT_FILLER = \"filler\";\r\nexport const CAT_TOOL = \"tool\";\r\n\r\n\r\nexport interface IPromptDescription {\r\n  description: string,\r\n  type: string,\r\n  pattern: RegExp,\r\n  message: string,\r\n  default: string,\r\n  required: boolean\r\n}\r\n\r\nexport const aOperatorNames = [\"starting with\", \"ending with\", \"containing\", \"excluding\", \"having\", \"being\"];\r\nexport type OperatorName = \"starting with\" | \"ending with\" | \"containing\" | \"being\" | \"excluding\" | \"having\";\r\n\r\nexport interface IOperator {\r\n  operator : OperatorName,\r\n  code : string,\r\n  arity : number,\r\n  argcategory : [ string[] ]\r\n}\r\n\r\nexport type IRecord = { [key : string] : string\r\n};\r\n\r\n\r\nexport interface IWhatIsAnswer {\r\n  sentence: ISentence,\r\n  record : IRecord,\r\n  category : string,\r\n  result: string,\r\n  _ranking : number\r\n}\r\n\r\n\r\nexport interface IWhatIsTupelAnswer {\r\n  sentence: ISentence,\r\n  record : IRecord,\r\n  categories : string[],\r\n  result: string[],\r\n  _ranking : number\r\n}\r\n\r\nexport interface IMatchedSetRecord {\r\n  setId : string,\r\n  record : IRecord\r\n};\r\nexport type IMatchedSetRecords = IMatchedSetRecord[];\r\n/**\r\n * Map category -> value\r\n */\r\nexport type IMatchSet = { [key : string] : string};\r\n\r\nexport const  enum EnumRuleType {\r\n  WORD,\r\n  REGEXP\r\n}\r\n\r\nexport interface IToolSet {\r\n      set: string[],\r\n      response: string\r\n    };\r\n\r\nexport type IToolSets = {\r\n    [key: string]: IToolSet\r\n    };\r\n/**\r\n * @interface ITool\r\n *\r\n * var oTool = { 'name' : 'FLPD',\r\n *   'requires' : { 'systemId' : {}, 'client' :{}},\r\n *   'optional' : { 'catalog' : {}, 'group' :{}}\r\n * };\r\n*/\r\nexport interface ITool {\r\n  name: string,\r\n  requires: { [key: string]: Object },\r\n  optional?: { [key: string]: Object },\r\n  sets?: IToolSets\r\n}\r\n\r\nexport interface IToolMatchResult {\r\n  required: { [key: string]: IWord },\r\n  missing: { [key: string]: number },\r\n  optional?: { [key: string]: IWord },\r\n  spurious: { [key: string]: number },\r\n  toolmentioned: IWord[]\r\n}\r\n\r\nexport interface IPrompt {\r\n  text: string,\r\n  category: string\r\n}\r\n\r\nexport interface IToolMatch {\r\n  toolmatchresult: IToolMatchResult,\r\n  sentence: ISentence,\r\n  tool: ITool,\r\n  rank: number\r\n}\r\n\r\nexport interface IWord {\r\n  string: string,\r\n  matchedString: string,\r\n  category?: string,\r\n  _ranking?: number,\r\n  levenmatch?: number,\r\n  reinforce?: number\r\n}\r\n\r\nexport type ISentence = Array<IWord>;\r\n\r\nexport interface IRule {\r\n  type: EnumRuleType,\r\n  key: string,\r\n  word?: string,\r\n  regexp?: RegExp,\r\n  argsMap?: { [key: number]: string }  // a map of regexp match group -> context key\r\n  // e.g. /([a-z0-9]{3,3})CLNT([\\d{3,3}])/\r\n  //      { 1 : \"systemId\", 2 : \"client\" }\r\n  follows: context\r\n}\r\n\r\nexport interface IntentRule {\r\n  type: EnumRuleType,\r\n  regexp: RegExp,\r\n  argsMap: { [key: string]: number }  // a map of regexp match group -> context key\r\n  // e.g. /([a-z0-9]{3,3})CLNT([\\d{3,3}])/\r\n  //      { 1 : \"systemId\", 2 : \"client\" }\r\n  follows?: context\r\n}\r\n\r\n/**\r\n * A rule matching a single string\r\n */\r\nexport interface mRule {\r\n  type: EnumRuleType,\r\n  word?: string,\r\n  lowercaseword? : string,\r\n  regexp?: RegExp,\r\n  matchedString?: string,\r\n  matchIndex?: number,\r\n  category: string,\r\n  bitindex : number,\r\n  range? : { low: number, high: number},\r\n  /**\r\n   * only use an exact match\r\n   */\r\n  exactOnly? : boolean,\r\n  _ranking?: number\r\n}\r\n\r\nexport interface IWordRules {\r\n  rules : Array<mRule>,\r\n  bitindex: number\r\n}\r\n\r\nexport interface SplitRules {\r\n  allRules: Array<mRule>,\r\n  nonWordRules : Array<mRule>,\r\n  wordMap: { [key : string] : IWordRules }\r\n};\r\n\r\nexport interface ICategorizedString {\r\n  string: string,\r\n  matchedString: string,\r\n  category: string,\r\n  breakdown?: Array<any>\r\n  score?: number,\r\n  _ranking?: number,\r\n  levenmatch?: number  // a distance ranking\r\n}\r\n\r\nexport type context = { [key: string]: string };\r\n\r\n/**\r\n * Defines the interface for an analysis\r\n * reponse\r\n */\r\nexport interface IResponse {\r\n  rating: number,\r\n  type: EnumResponseCode,\r\n  query: string,\r\n  context: { [key: string]: string },\r\n  text: string,\r\n  action: IAction,\r\n  prompts: {\r\n    [key: string]: {\r\n      text: string,\r\n      /**\r\n       * Follows the features of NPM prompts\r\n       */\r\n      description: IPromptDescription\r\n    };\r\n  }\r\n}\r\n\r\nexport const enum EnumActionType {\r\n  STARTURL,\r\n  STARTCMDLINE\r\n}\r\n\r\nexport interface IAction {\r\n  data: any,\r\n  type: EnumActionType,\r\n  pattern: string,\r\n  concrete: string\r\n}\r\n\r\n\r\nexport interface ICategoryDesc {\r\n  name: string,\r\n  importance? : number,\r\n  description? : string,\r\n  iskey? : boolean\r\n  exactMatch: boolean,\r\n  synonyms? : string[];\r\n}\r\n\r\nexport interface IModels {\r\n    full : {\r\n      domain : { [key : string] : {\r\n          description: string,\r\n          bitindex : number,\r\n          categories : { [key : string] : ICategoryDesc }\r\n        }\r\n      }\r\n    },\r\n    domains: string[],\r\n    tools: ITool[],\r\n    category: string[],\r\n    operators : { [key: string] : IOperator },\r\n    mRules: mRule[],\r\n    rules : SplitRules,\r\n    records: any[]\r\n    seenRules?: { [key: string]: mRule[] },\r\n    meta : {\r\n        // entity -> relation -> target\r\n        t3 : { [key: string] : { [key : string] : any }}\r\n    }\r\n}\r\n"],"sourceRoot":"ABC"}