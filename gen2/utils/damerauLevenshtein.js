'use strict';
// based on: http://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Levenshtein_distance
// and:  http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance
/**
 * Distance of strings algorithm
 * @module fsdevstart.utils.damerauLevenshtein
 */
/**
 * a function calculating distance between two strings
 * according to the damerau Levenshtein algorithm
 * (this algorithm, in contrast to plain levenshtein treats
 * swapping of characters a distance 1  "word"  <-> "wrod )
 * @param {string} a
 * @param {string} b
 * @public
 */

function levenshteinDamerau(a, b) {
    var i;
    var j;
    var cost;
    var d = [];
    if (a.length === 0) {
        return b.length;
    }
    if (b.length === 0) {
        return a.length;
    }
    for (i = 0; i <= a.length; i++) {
        d[i] = [];
        d[i][0] = i;
    }
    for (j = 0; j <= b.length; j++) {
        d[0][j] = j;
    }
    for (i = 1; i <= a.length; i++) {
        for (j = 1; j <= b.length; j++) {
            if (a.charAt(i - 1) === b.charAt(j - 1)) {
                cost = 0;
            } else {
                cost = 1;
            }
            d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
            if (i > 1 && j > 1 && a.charAt(i - 1) === b.charAt(j - 2) && a.charAt(i - 2) === b.charAt(j - 1)) {
                d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
            }
        }
    }
    return d[a.length][b.length];
}
exports.levenshteinDamerau = levenshteinDamerau;
function levenshtein(a, b) {
    //return 2.0 * sift3Distance(a,b); //,6,7); // + b.length / 2);
    return levenshteinDamerau(a, b);
}
exports.levenshtein = levenshtein;
function sift3Distance(s1, s2) {
    if (s1 == null || s1.length === 0) {
        if (s2 == null || s2.length === 0) {
            return 0;
        } else {
            return s2.length;
        }
    }
    if (s2 == null || s2.length === 0) {
        return s1.length;
    }
    if (Math.abs(s1.length - s2.length) > 20) {
        return Math.max(s1.length, s2.length) / 2;
    }
    var c = 0;
    var offset1 = 0;
    var offset2 = 0;
    var lcs = 0;
    var maxOffset = 3;
    while (c + offset1 < s1.length && c + offset2 < s2.length) {
        if (s1.charAt(c + offset1) == s2.charAt(c + offset2)) {
            lcs++;
        } else {
            offset1 = 0;
            offset2 = 0;
            for (var i = 0; i < maxOffset; i++) {
                if (c + i < s1.length && s1.charAt(c + i) == s2.charAt(c)) {
                    offset1 = i;
                    break;
                }
                if (c + i < s2.length && s1.charAt(c) == s2.charAt(c + i)) {
                    offset2 = i;
                    break;
                }
            }
        }
        c++;
    }
    return (s1.length + s2.length) / 2 - lcs;
}
exports.sift3Distance = sift3Distance;
//  Sift4 - common version
// https://siderite.blogspot.com/2014/11/super-fast-and-accurate-string-distance.html
// online algorithm to compute the distance between two strings in O(n)
// maxOffset is the number of characters to search for matching letters
// maxDistance is the distance at which the algorithm should stop computing the value and just exit (the strings are too different anyway)
function sift4(s1, s2, maxOffset, maxDistance) {
    if (!s1 || !s1.length) {
        if (!s2) {
            return 0;
        }
        return s2.length;
    }
    if (!s2 || !s2.length) {
        return s1.length;
    }
    var l1 = s1.length;
    var l2 = s2.length;
    if (Math.abs(l1 - l2) > maxDistance) {
        return 50000;
    }
    var c1 = 0; //cursor for string 1
    var c2 = 0; //cursor for string 2
    var lcss = 0; //largest common subsequence
    var local_cs = 0; //local common substring
    var trans = 0; //number of transpositions ('ab' vs 'ba')
    var offset_arr = []; //offset pair array, for computing the transpositions
    while (c1 < l1 && c2 < l2) {
        if (s1.charAt(c1) == s2.charAt(c2)) {
            local_cs++;
            var isTrans = false;
            //see if current match is a transposition
            var i = 0;
            while (i < offset_arr.length) {
                var ofs = offset_arr[i];
                if (c1 <= ofs.c1 || c2 <= ofs.c2) {
                    // when two matches cross, the one considered a transposition is the one with the largest difference in offsets
                    isTrans = Math.abs(c2 - c1) >= Math.abs(ofs.c2 - ofs.c1);
                    if (isTrans) {
                        trans++;
                    } else {
                        if (!ofs.trans) {
                            ofs.trans = true;
                            trans++;
                        }
                    }
                    break;
                } else {
                    if (c1 > ofs.c2 && c2 > ofs.c1) {
                        offset_arr.splice(i, 1);
                    } else {
                        i++;
                    }
                }
            }
            offset_arr.push({
                c1: c1,
                c2: c2,
                trans: isTrans
            });
        } else {
            lcss += local_cs;
            local_cs = 0;
            if (c1 != c2) {
                c1 = c2 = Math.min(c1, c2); //using min allows the computation of transpositions
            }
            //if matching characters are found, remove 1 from both cursors (they get incremented at the end of the loop)
            //so that we can have only one code block handling matches
            for (var i = 0; i < maxOffset && (c1 + i < l1 || c2 + i < l2); i++) {
                if (c1 + i < l1 && s1.charAt(c1 + i) == s2.charAt(c2)) {
                    c1 += i - 1;
                    c2--;
                    break;
                }
                if (c2 + i < l2 && s1.charAt(c1) == s2.charAt(c2 + i)) {
                    c1--;
                    c2 += i - 1;
                    break;
                }
            }
        }
        c1++;
        c2++;
        if (maxDistance) {
            var temporaryDistance = Math.max(c1, c2) - lcss + trans;
            if (temporaryDistance >= maxDistance) return 50000; // Math.round(temporaryDistance);
        }
        // this covers the case where the last match is on the last token in list, so that it can compute transpositions correctly
        if (c1 >= l1 || c2 >= l2) {
            lcss += local_cs;
            local_cs = 0;
            c1 = c2 = Math.min(c1, c2);
        }
    }
    lcss += local_cs;
    return Math.round(Math.max(l1, l2) - lcss + trans); //add the cost of transpositions to the final result
}
exports.sift4 = sift4;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy9kYW1lcmF1TGV2ZW5zaHRlaW4udHMiXSwibmFtZXMiOlsibGV2ZW5zaHRlaW5EYW1lcmF1IiwiYSIsImIiLCJpIiwiaiIsImNvc3QiLCJkIiwibGVuZ3RoIiwiY2hhckF0IiwiTWF0aCIsIm1pbiIsImV4cG9ydHMiLCJsZXZlbnNodGVpbiIsInNpZnQzRGlzdGFuY2UiLCJzMSIsInMyIiwiYWJzIiwibWF4IiwiYyIsIm9mZnNldDEiLCJvZmZzZXQyIiwibGNzIiwibWF4T2Zmc2V0Iiwic2lmdDQiLCJtYXhEaXN0YW5jZSIsImwxIiwibDIiLCJjMSIsImMyIiwibGNzcyIsImxvY2FsX2NzIiwidHJhbnMiLCJvZmZzZXRfYXJyIiwiaXNUcmFucyIsIm9mcyIsInNwbGljZSIsInB1c2giLCJ0ZW1wb3JhcnlEaXN0YW5jZSIsInJvdW5kIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBO0FBQ0E7QUFHQTs7OztBQUtBOzs7Ozs7Ozs7O0FBU0EsU0FBQUEsa0JBQUEsQ0FBb0NDLENBQXBDLEVBQWdEQyxDQUFoRCxFQUEwRDtBQUN4RCxRQUFJQyxDQUFKO0FBQ0EsUUFBSUMsQ0FBSjtBQUNBLFFBQUlDLElBQUo7QUFDQSxRQUFJQyxJQUFJLEVBQVI7QUFDQSxRQUFJTCxFQUFFTSxNQUFGLEtBQWEsQ0FBakIsRUFBb0I7QUFDbEIsZUFBT0wsRUFBRUssTUFBVDtBQUNEO0FBQ0QsUUFBSUwsRUFBRUssTUFBRixLQUFhLENBQWpCLEVBQW9CO0FBQ2xCLGVBQU9OLEVBQUVNLE1BQVQ7QUFDRDtBQUNELFNBQUtKLElBQUksQ0FBVCxFQUFZQSxLQUFLRixFQUFFTSxNQUFuQixFQUEyQkosR0FBM0IsRUFBZ0M7QUFDOUJHLFVBQUdILENBQUgsSUFBUyxFQUFUO0FBQ0FHLFVBQUdILENBQUgsRUFBUSxDQUFSLElBQWNBLENBQWQ7QUFDRDtBQUNELFNBQUtDLElBQUksQ0FBVCxFQUFZQSxLQUFLRixFQUFFSyxNQUFuQixFQUEyQkgsR0FBM0IsRUFBZ0M7QUFD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QVosSUFBZ0JDLElBQWhCLEdBQXFCRSxLQUEzQztBQUNBLGdCQUFJTSxxQkFBbUJiLFdBQXZCLEVBQW9DLE9BQU8sS0FBUCxDQUZ4QyxDQUVzRDtBQUNyRDtBQUNEO0FBQ0EsWUFBS0csTUFBTUYsRUFBUCxJQUFlRyxNQUFNRixFQUF6QixFQUE4QjtBQUMxQkcsb0JBQU1DLFFBQU47QUFDQUEsdUJBQVMsQ0FBVDtBQUNBSCxpQkFBR0MsS0FBR25CLEtBQUtDLEdBQUwsQ0FBU2lCLEVBQVQsRUFBWUMsRUFBWixDQUFOO0FBQ0g7QUFDSjtBQUNEQyxZQUFNQyxRQUFOO0FBQ0EsV0FBT3JCLEtBQUs2QixLQUFMLENBQVc3QixLQUFLUSxHQUFMLENBQVNRLEVBQVQsRUFBWUMsRUFBWixJQUFpQkcsSUFBakIsR0FBdUJFLEtBQWxDLENBQVAsQ0FoR2dELENBZ0dDO0FBQ3BEO0FBakdlcEIsUUFBQVksS0FBQSxHQUFLQSxLQUFMIiwiZmlsZSI6InV0aWxzL2RhbWVyYXVMZXZlbnNodGVpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG5cclxuLy8gYmFzZWQgb246IGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX2ltcGxlbWVudGF0aW9uL1N0cmluZ3MvTGV2ZW5zaHRlaW5fZGlzdGFuY2VcclxuLy8gYW5kOiAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EYW1lcmF1JUUyJTgwJTkzTGV2ZW5zaHRlaW5fZGlzdGFuY2VcclxuXHJcblxyXG4vKipcclxuICogRGlzdGFuY2Ugb2Ygc3RyaW5ncyBhbGdvcml0aG1cclxuICogQG1vZHVsZSBmc2RldnN0YXJ0LnV0aWxzLmRhbWVyYXVMZXZlbnNodGVpblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBhIGZ1bmN0aW9uIGNhbGN1bGF0aW5nIGRpc3RhbmNlIGJldHdlZW4gdHdvIHN0cmluZ3NcclxuICogYWNjb3JkaW5nIHRvIHRoZSBkYW1lcmF1IExldmVuc2h0ZWluIGFsZ29yaXRobVxyXG4gKiAodGhpcyBhbGdvcml0aG0sIGluIGNvbnRyYXN0IHRvIHBsYWluIGxldmVuc2h0ZWluIHRyZWF0c1xyXG4gKiBzd2FwcGluZyBvZiBjaGFyYWN0ZXJzIGEgZGlzdGFuY2UgMSAgXCJ3b3JkXCIgIDwtPiBcIndyb2QgKVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbGV2ZW5zaHRlaW5EYW1lcmF1IChhIDogc3RyaW5nLCBiIDogc3RyaW5nKSB7XHJcbiAgdmFyIGkgOiBudW1iZXJcclxuICB2YXIgaiA6IG51bWJlclxyXG4gIHZhciBjb3N0IDogbnVtYmVyXHJcbiAgdmFyIGQgPSBbXVxyXG4gIGlmIChhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIGIubGVuZ3RoXHJcbiAgfVxyXG4gIGlmIChiLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIGEubGVuZ3RoXHJcbiAgfVxyXG4gIGZvciAoaSA9IDA7IGkgPD0gYS5sZW5ndGg7IGkrKykge1xyXG4gICAgZFsgaSBdID0gW11cclxuICAgIGRbIGkgXVsgMCBdID0gaVxyXG4gIH1cclxuICBmb3IgKGogPSAwOyBqIDw9IGIubGVuZ3RoOyBqKyspIHtcclxuICAgIGRbIDAgXVsgaiBdID0galxyXG4gIH1cclxuICBmb3IgKGkgPSAxOyBpIDw9IGEubGVuZ3RoOyBpKyspIHtcclxuICAgIGZvciAoaiA9IDE7IGogPD0gYi5sZW5ndGg7IGorKykge1xyXG4gICAgICBpZiAoYS5jaGFyQXQoaSAtIDEpID09PSBiLmNoYXJBdChqIC0gMSkpIHtcclxuICAgICAgICBjb3N0ID0gMFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvc3QgPSAxXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRbIGkgXVsgaiBdID0gTWF0aC5taW4oZFsgaSAtIDEgXVsgaiBdICsgMSwgZFsgaSBdWyBqIC0gMSBdICsgMSwgZFsgaSAtIDEgXVsgaiAtIDEgXSArIGNvc3QpXHJcblxyXG4gICAgICBpZiAoXHJcblxyXG4gICAgICAgIGkgPiAxICYmXHJcblxyXG4gICAgICAgIGogPiAxICYmXHJcblxyXG4gICAgICAgIGEuY2hhckF0KGkgLSAxKSA9PT0gYi5jaGFyQXQoaiAtIDIpICYmXHJcblxyXG4gICAgICAgIGEuY2hhckF0KGkgLSAyKSA9PT0gYi5jaGFyQXQoaiAtIDEpXHJcblxyXG4gICAgICApIHtcclxuICAgICAgICBkW2ldW2pdID0gTWF0aC5taW4oXHJcblxyXG4gICAgICAgICAgZFtpXVtqXSxcclxuXHJcbiAgICAgICAgICBkW2kgLSAyXVtqIC0gMl0gKyBjb3N0XHJcblxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRbIGEubGVuZ3RoIF1bIGIubGVuZ3RoIF1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsZXZlbnNodGVpbiAoYSA6IHN0cmluZywgYiA6IHN0cmluZykge1xyXG4gIC8vcmV0dXJuIDIuMCAqIHNpZnQzRGlzdGFuY2UoYSxiKTsgLy8sNiw3KTsgLy8gKyBiLmxlbmd0aCAvIDIpO1xyXG4gIHJldHVybiBsZXZlbnNodGVpbkRhbWVyYXUoYSxiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNpZnQzRGlzdGFuY2UoczEsIHMyKSB7XHJcbiAgICBpZiAoczEgPT0gbnVsbCB8fCBzMS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBpZiAoczIgPT0gbnVsbCB8fCBzMi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHMyLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHMyID09IG51bGwgfHwgczIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHMxLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGlmIChNYXRoLmFicyhzMS5sZW5ndGggIC0gczIubGVuZ3RoKSA+IDIwKSB7XHJcbiAgICAgIHJldHVybiAgTWF0aC5tYXgoczEubGVuZ3RoLCBzMi5sZW5ndGgpLzI7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGMgPSAwO1xyXG4gICAgdmFyIG9mZnNldDEgPSAwO1xyXG4gICAgdmFyIG9mZnNldDIgPSAwO1xyXG4gICAgdmFyIGxjcyA9IDA7XHJcbiAgICB2YXIgbWF4T2Zmc2V0ID0gMztcclxuXHJcbiAgICB3aGlsZSAoKGMgKyBvZmZzZXQxIDwgczEubGVuZ3RoKSAmJiAoYyArIG9mZnNldDIgPCBzMi5sZW5ndGgpKSB7XHJcbiAgICAgICAgaWYgKHMxLmNoYXJBdChjICsgb2Zmc2V0MSkgPT0gczIuY2hhckF0KGMgKyBvZmZzZXQyKSkge1xyXG4gICAgICAgICAgICBsY3MrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvZmZzZXQxID0gMDtcclxuICAgICAgICAgICAgb2Zmc2V0MiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4T2Zmc2V0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICgoYyArIGkgPCBzMS5sZW5ndGgpICYmIChzMS5jaGFyQXQoYyArIGkpID09IHMyLmNoYXJBdChjKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQxID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgoYyArIGkgPCBzMi5sZW5ndGgpICYmIChzMS5jaGFyQXQoYykgPT0gczIuY2hhckF0KGMgKyBpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQyID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKHMxLmxlbmd0aCArIHMyLmxlbmd0aCkgLyAyIC0gbGNzO1xyXG59XHJcblxyXG4vLyAgU2lmdDQgLSBjb21tb24gdmVyc2lvblxyXG4vLyBodHRwczovL3NpZGVyaXRlLmJsb2dzcG90LmNvbS8yMDE0LzExL3N1cGVyLWZhc3QtYW5kLWFjY3VyYXRlLXN0cmluZy1kaXN0YW5jZS5odG1sXHJcbi8vIG9ubGluZSBhbGdvcml0aG0gdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gc3RyaW5ncyBpbiBPKG4pXHJcbi8vIG1heE9mZnNldCBpcyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gc2VhcmNoIGZvciBtYXRjaGluZyBsZXR0ZXJzXHJcbi8vIG1heERpc3RhbmNlIGlzIHRoZSBkaXN0YW5jZSBhdCB3aGljaCB0aGUgYWxnb3JpdGhtIHNob3VsZCBzdG9wIGNvbXB1dGluZyB0aGUgdmFsdWUgYW5kIGp1c3QgZXhpdCAodGhlIHN0cmluZ3MgYXJlIHRvbyBkaWZmZXJlbnQgYW55d2F5KVxyXG5leHBvcnQgZnVuY3Rpb24gc2lmdDQoczEsIHMyLCBtYXhPZmZzZXQsIG1heERpc3RhbmNlKSB7XHJcbiAgICBpZiAoIXMxfHwhczEubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFzMikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHMyLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXMyfHwhczIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHMxLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbDE9czEubGVuZ3RoO1xyXG4gICAgdmFyIGwyPXMyLmxlbmd0aDtcclxuICAgIGlmKE1hdGguYWJzKGwxIC0gbDIpID4gbWF4RGlzdGFuY2UpIHtcclxuICAgICAgcmV0dXJuIDUwMDAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjMSA9IDA7ICAvL2N1cnNvciBmb3Igc3RyaW5nIDFcclxuICAgIHZhciBjMiA9IDA7ICAvL2N1cnNvciBmb3Igc3RyaW5nIDJcclxuICAgIHZhciBsY3NzID0gMDsgIC8vbGFyZ2VzdCBjb21tb24gc3Vic2VxdWVuY2VcclxuICAgIHZhciBsb2NhbF9jcyA9IDA7IC8vbG9jYWwgY29tbW9uIHN1YnN0cmluZ1xyXG4gICAgdmFyIHRyYW5zID0gMDsgIC8vbnVtYmVyIG9mIHRyYW5zcG9zaXRpb25zICgnYWInIHZzICdiYScpXHJcbiAgICB2YXIgb2Zmc2V0X2Fycj1bXTsgIC8vb2Zmc2V0IHBhaXIgYXJyYXksIGZvciBjb21wdXRpbmcgdGhlIHRyYW5zcG9zaXRpb25zXHJcblxyXG4gICAgd2hpbGUgKChjMSA8IGwxKSAmJiAoYzIgPCBsMikpIHtcclxuICAgICAgICBpZiAoczEuY2hhckF0KGMxKSA9PSBzMi5jaGFyQXQoYzIpKSB7XHJcbiAgICAgICAgICAgIGxvY2FsX2NzKys7XHJcbiAgICAgICAgICAgIHZhciBpc1RyYW5zPWZhbHNlO1xyXG4gICAgICAgICAgICAvL3NlZSBpZiBjdXJyZW50IG1hdGNoIGlzIGEgdHJhbnNwb3NpdGlvblxyXG4gICAgICAgICAgICB2YXIgaT0wO1xyXG4gICAgICAgICAgICB3aGlsZSAoaTxvZmZzZXRfYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mcz1vZmZzZXRfYXJyW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMxPD1vZnMuYzEgfHwgYzIgPD0gb2ZzLmMyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0d28gbWF0Y2hlcyBjcm9zcywgdGhlIG9uZSBjb25zaWRlcmVkIGEgdHJhbnNwb3NpdGlvbiBpcyB0aGUgb25lIHdpdGggdGhlIGxhcmdlc3QgZGlmZmVyZW5jZSBpbiBvZmZzZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUcmFucz1NYXRoLmFicyhjMi1jMSk+PU1hdGguYWJzKG9mcy5jMi1vZnMuYzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMrKztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2ZzLnRyYW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZnMudHJhbnM9dHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjMT5vZnMuYzIgJiYgYzI+b2ZzLmMxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldF9hcnIuc3BsaWNlKGksMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvZmZzZXRfYXJyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYzE6YzEsXHJcbiAgICAgICAgICAgICAgICBjMjpjMixcclxuICAgICAgICAgICAgICAgIHRyYW5zOmlzVHJhbnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGNzcys9bG9jYWxfY3M7XHJcbiAgICAgICAgICAgIGxvY2FsX2NzPTA7XHJcbiAgICAgICAgICAgIGlmIChjMSE9YzIpIHtcclxuICAgICAgICAgICAgICAgIGMxPWMyPU1hdGgubWluKGMxLGMyKTsgIC8vdXNpbmcgbWluIGFsbG93cyB0aGUgY29tcHV0YXRpb24gb2YgdHJhbnNwb3NpdGlvbnNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIG1hdGNoaW5nIGNoYXJhY3RlcnMgYXJlIGZvdW5kLCByZW1vdmUgMSBmcm9tIGJvdGggY3Vyc29ycyAodGhleSBnZXQgaW5jcmVtZW50ZWQgYXQgdGhlIGVuZCBvZiB0aGUgbG9vcClcclxuICAgICAgICAgICAgLy9zbyB0aGF0IHdlIGNhbiBoYXZlIG9ubHkgb25lIGNvZGUgYmxvY2sgaGFuZGxpbmcgbWF0Y2hlc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heE9mZnNldCAmJiAoYzEraTxsMSB8fCBjMitpPGwyKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGMxICsgaSA8IGwxKSAmJiAoczEuY2hhckF0KGMxICsgaSkgPT0gczIuY2hhckF0KGMyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjMSs9IGktMTtcclxuICAgICAgICAgICAgICAgICAgICBjMi0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChjMiArIGkgPCBsMikgJiYgKHMxLmNoYXJBdChjMSkgPT0gczIuY2hhckF0KGMyICsgaSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYzEtLTtcclxuICAgICAgICAgICAgICAgICAgICBjMis9IGktMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjMSsrO1xyXG4gICAgICAgIGMyKys7XHJcbiAgICAgICAgaWYgKG1heERpc3RhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHRlbXBvcmFyeURpc3RhbmNlPU1hdGgubWF4KGMxLGMyKS1sY3NzK3RyYW5zO1xyXG4gICAgICAgICAgICBpZiAodGVtcG9yYXJ5RGlzdGFuY2U+PW1heERpc3RhbmNlKSByZXR1cm4gNTAwMDA7IC8vIE1hdGgucm91bmQodGVtcG9yYXJ5RGlzdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzIGNvdmVycyB0aGUgY2FzZSB3aGVyZSB0aGUgbGFzdCBtYXRjaCBpcyBvbiB0aGUgbGFzdCB0b2tlbiBpbiBsaXN0LCBzbyB0aGF0IGl0IGNhbiBjb21wdXRlIHRyYW5zcG9zaXRpb25zIGNvcnJlY3RseVxyXG4gICAgICAgIGlmICgoYzEgPj0gbDEpIHx8IChjMiA+PSBsMikpIHtcclxuICAgICAgICAgICAgbGNzcys9bG9jYWxfY3M7XHJcbiAgICAgICAgICAgIGxvY2FsX2NzPTA7XHJcbiAgICAgICAgICAgIGMxPWMyPU1hdGgubWluKGMxLGMyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsY3NzKz1sb2NhbF9jcztcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWF4KGwxLGwyKS0gbGNzcyArdHJhbnMpOyAvL2FkZCB0aGUgY29zdCBvZiB0cmFuc3Bvc2l0aW9ucyB0byB0aGUgZmluYWwgcmVzdWx0XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
