'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function deepFreeze(o) {
    if ((typeof o === "undefined" ? "undefined" : _typeof(o)) === "object") {
        Object.keys(o).forEach(function (sKey) {
            deepFreeze(o[sKey]);
        });
        Object.freeze(o);
    }
}
exports.deepFreeze = deepFreeze;
function listToCommaAnd(list, quote) {
    quote = quote || "";
    if (list.length === 0) {
        return quote + quote;
    }
    var base = list.slice(0, list.length - 1).join(quote + ", " + quote);
    if (base) {
        base = quote + base + quote + ' and ' + quote + list[list.length - 1] + quote;
        return base;
    }
    return quote + list[0] + quote;
}
exports.listToCommaAnd = listToCommaAnd;
function listToQuotedCommaAnd(list) {
    return listToCommaAnd(list, '"');
}
exports.listToQuotedCommaAnd = listToQuotedCommaAnd;
// courtesy of
// http://stackoverflow.com/questions/4459928/how-to-deep-clone-in-javascript
function cloneDeep(item) {
    if (!item) {
        return item;
    } // null, undefined values check
    var types = [Number, String, Boolean],
        result;
    // normalizing primitives if someone did new String('aaa'), or new Number('444');
    types.forEach(function (type) {
        if (item instanceof type) {
            result = type(item);
        }
    });
    if (typeof result == "undefined") {
        if (Object.prototype.toString.call(item) === "[object Array]") {
            result = [];
            item.forEach(function (child, index, array) {
                result[index] = cloneDeep(child);
            });
        } else if ((typeof item === 'undefined' ? 'undefined' : typeof item === "undefined" ? "undefined" : _typeof(item)) == "object") {
            // testing that this is DOM
            if (!item.prototype) {
                if (item instanceof Date) {
                    result = new Date(item);
                } else {
                    // it is an object literal
                    result = {};
                    for (var i in item) {
                        result[i] = cloneDeep(item[i]);
                    }
                }
            } else {
                // depending what you would like here,
                //   // just keep the reference, or create new object
                //   if (false && item.constructor) {
                // would not advice to do that, reason? Read below
                //        result = new item.constructor();
                //    } else {
                result = item;
            }
        } else {
            result = item;
        }
    }
    return result;
}
exports.cloneDeep = cloneDeep;
exports.ArrayUtils = {
    indexOf: function indexOf(oMember, aArr, fnComp) {
        fnComp = fnComp || function (a, b) {
            return a === b;
        };
        var resIndex = -1;
        aArr.every(function (oMemberArr, index) {
            var u = fnComp(oMemberArr, oMember);
            if (u) {
                resIndex = index;
                return false;
            }
            return true;
        });
        return resIndex;
    },
    presentIn: function presentIn(oMember, aArr, fnComp) {
        return exports.ArrayUtils.indexOf(oMember, aArr, fnComp) >= 0;
    },
    setMinus: function setMinus(aRR1, aRR2, fnComp) {
        fnComp = fnComp || function (a, b) {
            return a === b;
        };
        return aRR1.reduce(function (Result, oMember, index) {
            if (!exports.ArrayUtils.presentIn(oMember, aRR2, fnComp) && !exports.ArrayUtils.presentIn(oMember, Result, fnComp)) {
                Result.push(oMember);
            }
            return Result;
        }, []);
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlscy91dGlscy50cyJdLCJuYW1lcyI6WyJkZWVwRnJlZXplIiwibyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwic0tleSIsImZyZWV6ZSIsImV4cG9ydHMiLCJsaXN0VG9Db21tYUFuZCIsImxpc3QiLCJxdW90ZSIsImxlbmd0aCIsImJhc2UiLCJzbGljZSIsImpvaW4iLCJsaXN0VG9RdW90ZWRDb21tYUFuZCIsImNsb25lRGVlcCIsIml0ZW0iLCJ0eXBlcyIsIk51bWJlciIsIlN0cmluZyIsIkJvb2xlYW4iLCJyZXN1bHQiLCJ0eXBlIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiY2hpbGQiLCJpbmRleCIsImFycmF5IiwiRGF0ZSIsImkiLCJBcnJheVV0aWxzIiwiaW5kZXhPZiIsIm9NZW1iZXIiLCJhQXJyIiwiZm5Db21wIiwiYSIsImIiLCJyZXNJbmRleCIsImV2ZXJ5Iiwib01lbWJlckFyciIsInUiLCJwcmVzZW50SW4iLCJzZXRNaW51cyIsImFSUjEiLCJhUlIyIiwicmVkdWNlIiwiUmVzdWx0IiwicHVzaCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFDQSxTQUFBQSxVQUFBLENBQTJCQyxDQUEzQixFQUFrQztBQUNoQyxRQUFJLFFBQU9BLENBQVAseUNBQU9BLENBQVAsT0FBYSxRQUFqQixFQUEyQjtBQUN6QkMsZUFBT0MsSUFBUCxDQUFZRixDQUFaLEVBQWVHLE9BQWYsQ0FBdUIsVUFBU0MsSUFBVCxFQUFhO0FBQ2xDTCx1QkFBV0MsRUFBRUksSUFBRixDQUFYO0FBQ0QsU0FGRDtBQUdBSCxlQUFPSSxNQUFQLENBQWNMLENBQWQ7QUFDRDtBQUNGO0FBUGVNLFFBQUFQLFVBQUEsR0FBVUEsVUFBVjtBQVNoQixTQUFBUSxjQUFBLENBQStCQyxJQUEvQixFQUFnREMsS0FBaEQsRUFBK0Q7QUFDM0RBLFlBQVFBLFNBQVMsRUFBakI7QUFDQSxRQUFJRCxLQUFLRSxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLGVB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QUEyQjtBQUNwQyxnQkFBSWMsSUFBSU4sT0FBT0ssVUFBUCxFQUFrQlAsT0FBbEIsQ0FBUjtBQUNBLGdCQUFHUSxDQUFILEVBQU07QUFDSkgsMkJBQVdYLEtBQVg7QUFDQSx1QkFBTyxLQUFQO0FBQ0Q7QUFDRCxtQkFBTyxJQUFQO0FBQ0QsU0FQRDtBQVFBLGVBQU9XLFFBQVA7QUFDRCxLQWR1QjtBQWdCeEJJLGVBQVksbUJBQVlULE9BQVosRUFBeUJDLElBQXpCLEVBQTBDQyxNQUExQyxFQUE2RDtBQUN2RSxlQUFPN0IsUUFBQXlCLFVBQUEsQ0FBV0MsT0FBWCxDQUFtQkMsT0FBbkIsRUFBNEJDLElBQTVCLEVBQWtDQyxNQUFsQyxLQUE2QyxDQUFwRDtBQUNELEtBbEJ1QjtBQXFCeEJRLGNBQVcsa0JBQVlDLElBQVosRUFBNkJDLElBQTdCLEVBQThDVixNQUE5QyxFQUFpRTtBQUMxRUEsaUJBQVNBLFVBQVUsVUFBVUMsQ0FBVixFQUFlQyxDQUFmLEVBQWtCO0FBQUksbUJBQU9ELE1BQU1DLENBQWI7QUFBZ0IsU0FBekQ7QUFDQSxlQUFRTyxLQUFLRSxNQUFMLENBQVksVUFBU0MsTUFBVCxFQUFpQmQsT0FBakIsRUFBMEJOLEtBQTFCLEVBQStCO0FBQ2pELGdCQUFJLENBQUNyQixRQUFBeUIsVUFBQSxDQUFXVyxTQUFYLENBQXFCVCxPQUFyQixFQUE4QlksSUFBOUIsRUFBb0NWLE1BQXBDLENBQUQsSUFBZ0QsQ0FBQzdCLFFBQUF5QixVQUFBLENBQVdXLFNBQVgsQ0FBcUJULE9BQXJCLEVBQThCYyxNQUE5QixFQUFzQ1osTUFBdEMsQ0FBckQsRUFBb0c7QUFDbEdZLHVCQUFPQyxJQUFQLENBQVlmLE9BQVo7QUFDRDtBQUNELG1CQUFPYyxNQUFQO0FBQ0QsU0FMTyxFQUtOLEVBTE0sQ0FBUjtBQU1EO0FBN0J1QixDQUFiIiwiZmlsZSI6InV0aWxzL3V0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBGcmVlemUobyA6IGFueSkge1xuICBpZiAodHlwZW9mIG8gPT09IFwib2JqZWN0XCIpIHtcbiAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKHNLZXkpIHtcbiAgICAgIGRlZXBGcmVlemUob1tzS2V5XSk7XG4gICAgfSk7XG4gICAgT2JqZWN0LmZyZWV6ZShvKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdFRvQ29tbWFBbmQobGlzdCA6IHN0cmluZ1tdLCBxdW90ZT8gOiBzdHJpbmcpIHtcbiAgICBxdW90ZSA9IHF1b3RlIHx8IFwiXCI7XG4gICAgaWYoIGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBxdW90ZSArIHF1b3RlO1xuICAgIH1cbiAgICB2YXIgYmFzZSA9IGxpc3Quc2xpY2UoMCxsaXN0Lmxlbmd0aC0xKS5qb2luKHF1b3RlICsgXCIsIFwiICsgcXVvdGUpO1xuICAgIGlmKGJhc2UpIHtcbiAgICAgICAgYmFzZSA9IHF1b3RlICsgYmFzZSArIHF1b3RlICsgJyBhbmQgJyArIHF1b3RlICsgbGlzdFtsaXN0Lmxlbmd0aC0xXSArIHF1b3RlO1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgcmV0dXJuIHF1b3RlICsgbGlzdFswXSArIHF1b3RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdFRvUXVvdGVkQ29tbWFBbmQobGlzdCA6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIGxpc3RUb0NvbW1hQW5kKGxpc3QsJ1wiJyk7XG59XG5cbi8vIGNvdXJ0ZXN5IG9mXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ0NTk5MjgvaG93LXRvLWRlZXAtY2xvbmUtaW4tamF2YXNjcmlwdFxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRGVlcChpdGVtIDogYW55KSA6IGFueSAge1xuICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9IC8vIG51bGwsIHVuZGVmaW5lZCB2YWx1ZXMgY2hlY2tcbiAgICB2YXIgdHlwZXMgPSBbTnVtYmVyLCBTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgICByZXN1bHQ7XG4gICAgLy8gbm9ybWFsaXppbmcgcHJpbWl0aXZlcyBpZiBzb21lb25lIGRpZCBuZXcgU3RyaW5nKCdhYWEnKSwgb3IgbmV3IE51bWJlcignNDQ0Jyk7XG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHR5cGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlbSkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpdGVtLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2xvbmVEZWVwKGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaXRlbSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IHR5cGVvZiBpdGVtKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyB0ZXN0aW5nIHRoYXQgdGhpcyBpcyBET01cbiAgICAgICAgICAgIGlmICghaXRlbS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoaXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgYW4gb2JqZWN0IGxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmVEZWVwKGl0ZW1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlcGVuZGluZyB3aGF0IHlvdSB3b3VsZCBsaWtlIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gICAvLyBqdXN0IGtlZXAgdGhlIHJlZmVyZW5jZSwgb3IgY3JlYXRlIG5ldyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyAgIGlmIChmYWxzZSAmJiBpdGVtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gd291bGQgbm90IGFkdmljZSB0byBkbyB0aGF0LCByZWFzb24/IFJlYWQgYmVsb3dcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgcmVzdWx0ID0gbmV3IGl0ZW0uY29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICAvLyAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnR5cGUgZm5hID0gKGEgOiBudW1iZXIsYiA6IG51bWJlcikgPT4gbnVtYmVyO1xuXG50eXBlIGZuQ29tcDxUPiA9IChhIDogVCxiIDogVCkgPT4gYm9vbGVhbjtcblxuXG5leHBvcnQgY29uc3QgQXJyYXlVdGlscyA9IHtcblxuICBpbmRleE9mIDogZnVuY3Rpb248VD4ob01lbWJlciA6IFQsIGFBcnIgOiBBcnJheTxUPiwgZm5Db21wIDogZm5Db21wPFQ+ICkgOiBudW1iZXIge1xuICAgIGZuQ29tcCA9IGZuQ29tcCB8fCBmdW5jdGlvbiAoYTpULCBiOlQpIHsgcmV0dXJuIGEgPT09IGIgfTtcbiAgICB2YXIgcmVzSW5kZXggPSAtMTtcbiAgICBhQXJyLmV2ZXJ5KGZ1bmN0aW9uIChvTWVtYmVyQXJyLCBpbmRleCkge1xuICAgICAgdmFyIHUgPSBmbkNvbXAob01lbWJlckFycixvTWVtYmVyKTtcbiAgICAgIGlmKHUpIHtcbiAgICAgICAgcmVzSW5kZXggPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc0luZGV4O1xuICB9LFxuXG4gIHByZXNlbnRJbiA6IGZ1bmN0aW9uPFQ+KG9NZW1iZXIgOiBULCBhQXJyIDogQXJyYXk8VD4sIGZuQ29tcD8gOiBmbkNvbXA8VD4gKSA6IGJvb2xlYW4ge1xuICAgIHJldHVybiBBcnJheVV0aWxzLmluZGV4T2Yob01lbWJlciwgYUFyciwgZm5Db21wKSA+PSAwO1xuICB9LFxuXG5cbiAgc2V0TWludXMgOiBmdW5jdGlvbjxUPihhUlIxIDogQXJyYXk8VD4sIGFSUjIgOiBBcnJheTxUPiwgZm5Db21wPyA6IGZuQ29tcDxUPikgIHtcbiAgICBmbkNvbXAgPSBmbkNvbXAgfHwgZnVuY3Rpb24gKGE6VCwgYjpUKSB7IHJldHVybiBhID09PSBiIH07XG4gICAgcmV0dXJuICBhUlIxLnJlZHVjZShmdW5jdGlvbihSZXN1bHQsIG9NZW1iZXIsIGluZGV4KSB7XG4gICAgICBpZiAoIUFycmF5VXRpbHMucHJlc2VudEluKG9NZW1iZXIsIGFSUjIsIGZuQ29tcCkgJiYgIUFycmF5VXRpbHMucHJlc2VudEluKG9NZW1iZXIsIFJlc3VsdCwgZm5Db21wKSkge1xuICAgICAgICBSZXN1bHQucHVzaChvTWVtYmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZXN1bHQ7XG4gICAgfSxbXSBhcyBBcnJheTxUPik7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
