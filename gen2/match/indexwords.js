"use strict";

var IMatch = require("./ifmatch");
var pg = require("pg");
var debug = require("debug");
var debuglog = debug('indexwords');
var columns = ['lowercaseword', 'matchedstring', 'category'];
function insertWord(dburl, lowercaseword, matchedstring, category, callback) {
    pg.connect(dburl, function (err, client, pgDone) {
        var oEntry = {
            matchedstring: matchedstring,
            lowercaseword: lowercaseword,
            category: category
        };
        if (err) {
            // failed to acquire connection
            //logger.emit('error', err);
            debuglog('Error connecting to db' + err);
            callback(err);
        } else {
            var query = "INSERT INTO words (" + columns.join(",") + ") " +
            //   (convid, sessionid, user, message, response, meta) ` +
            "VALUES ( " +
            // $1, $2, ...
            columns.map(function (o, iIndex) {
                return "$" + (iIndex + 1);
            }).join(", ") + ")";
            var values = columns.map(function (sCol) {
                return oEntry[sCol];
            });
            //  [level, msg, meta instanceof Array ? JSON.stringify(meta) : meta],
            client.query(query, values, function (err, result) {
                pgDone();
                if (err) {
                    // logger.emit('error', err);
                    debuglog('Error inserting record into db ' + err + '\n' + values.join("\n"));
                    callback(err);
                } else {
                    //  logger.emit('logged');
                    callback(null, true);
                }
            });
        }
    });
}
exports.insertWord = insertWord;
function dumpWords(dburl, model) {
    // move
    model.mRules.forEach(function (mRule) {
        if (mRule.type === 0 /* WORD */) {
                insertWord(dburl, mRule.lowercaseword, mRule.matchedString, mRule.category, function () {});
            }
    });
}
exports.dumpWords = dumpWords;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1hdGNoL2luZGV4d29yZHMuanMiLCIuLi9zcmMvbWF0Y2gvaW5kZXh3b3Jkcy50cyJdLCJuYW1lcyI6WyJJTWF0Y2giLCJyZXF1aXJlIiwicGciLCJkZWJ1ZyIsImRlYnVnbG9nIiwiY29sdW1ucyIsImluc2VydFdvcmQiLCJkYnVybCIsImxvd2VyY2FzZXdvcmQiLCJtYXRjaGVkc3RyaW5nIiwiY2F0ZWdvcnkiLCJjYWxsYmFjayIsImNvbm5lY3QiLCJlcnIiLCJjbGllbnQiLCJwZ0RvbmUiLCJvRW50cnkiLCJxdWVyeSIsImpvaW4iLCJtYXAiLCJvIiwiaUluZGV4IiwidmFsdWVzIiwic0NvbCIsInJlc3VsdCIsImV4cG9ydHMiLCJkdW1wV29yZHMiLCJtb2RlbCIsIm1SdWxlcyIsImZvckVhY2giLCJtUnVsZSIsInR5cGUiLCJtYXRjaGVkU3RyaW5nIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUNHQSxJQUFBQSxTQUFBQyxRQUFBLFdBQUEsQ0FBQTtBQUNBLElBQUFDLEtBQUFELFFBQUEsSUFBQSxDQUFBO0FBQ0EsSUFBQUUsUUFBQUYsUUFBQSxPQUFBLENBQUE7QUFFQSxJQUFNRyxXQUFXRCxNQUFNLFlBQU4sQ0FBakI7QUFFQSxJQUFJRSxVQUFVLENBQUMsZUFBRCxFQUFrQixlQUFsQixFQUFtQyxVQUFuQyxDQUFkO0FBQ0EsU0FBQUMsVUFBQSxDQUEyQkMsS0FBM0IsRUFBMENDLGFBQTFDLEVBQWtFQyxhQUFsRSxFQUEwRkMsUUFBMUYsRUFBNEdDLFFBQTVHLEVBQTJKO0FBQ3pKVCxPQUFHVSxPQUFILENBQVdMLEtBQVgsRUFBa0IsVUFBQ00sR0FBRCxFQUFNQyxNQUFOLEVBQTBCQyxNQUExQixFQUFnQztBQUM5QyxZQUFJQyxTQUFVO0FBQ1pQLDJCQUFnQkEsYUFESjtBQUVaRCwyQkFBZ0JBLGFBRko7QUFHWkUsc0JBQVdBO0FBSEMsU0FBZDtBQUtBLFlBQUlHLEdBQUosRUFBUztBQUNQO0FBQ0E7QUFDQVQscUJBQVMsMkJBQTJCUyxHQUFwQztBQUNBRixxQkFBU0UsR0FBVDtBQUNELFNBTEQsTUFLTztBQUNMLGdCQUFJSSxRQUFPLHdCQUF3QlosUUFBUWEsSUFBUixDQUFhLEdBQWIsQ0FBeEIsR0FBNEMsSUFBNUM7QUFDWDtBQUNBLHVCQUZXO0FBR1g7QUFDQ2Isb0JBQVFjLEdBQVIsQ0FBWSxVQUFTQyxDQUFULEVBQVdDLE1BQVgsRUFBaUI7QUFBSSx1QkFBTyxPQUFPQSxTQUFPLENBQWQsQ0FBUDtBQUEwQixhQUEzRCxFQUE2REgsSUFBN0QsQ0FBa0UsSUFBbEUsQ0FKVSxHQUlnRSxHQUozRTtBQU1BLGdCQUFJSSxTQUFTakIsUUFBUWMsR0FBUixDQUFZLFVBQVNJLElBQVQsRUFBYTtBQUNqQyx1QkFBT1AsT0FBT08sSUFBUCxDQUFQO0FBQ0QsYUFGUyxDQUFiO0FBR0c7QUFDSFQsbUJBQU9HLEtBQVAsQ0FBYUEsS0FBYixFQUFtQkssTUFBbkIsRUFDYSxVQUFDVCxHQUFELEVBQU1XLE1BQU4sRUFBWTtBQUNyQlQ7QUFDQSxvQkFBSUYsR0FBSixFQUFTO0FBQ1I7QUFDQVQsNkJBQVMsb0NBQW9DUyxHQUFwQyxHQUEwQyxJQUExQyxHQUNOUyxPQUFPSixJQUFQLENBQVksSUFBWixDQURIO0FBRUNQLDZCQUFTRSxHQUFUO0FBQ0QsaUJBTEQsTUFLTztBQUNQO0FBQ0VGLDZCQUFTLElBQVQsRUFBZSxJQUFmO0FBQ0Q7QUFDSixhQVpEO0FBYUQ7QUFDRixLQXBDSDtBQXFDRDtBQXRDRGMsUUFBQW5CLFVBQUEsR0FBQUEsVUFBQTtBQXlDQSxTQUFBb0IsU0FBQSxDQUEwQm5CLEtBQTFCLEVBQTJDb0IsS0FBM0MsRUFBZ0U7QUFDOUQ7QUFDQUEsVUFBTUMsTUFBTixDQUFhQyxPQUFiLENBQXFCLFVBQVNDLEtBQVQsRUFBYztBQUNqQyxZQUFHQSxNQUFNQyxJQUFOLEtBQWUsQ0FBbEIsQ0FBa0IsVUFBbEIsRUFBNEM7QUFDMUN6QiwyQkFBV0MsS0FBWCxFQUFrQnVCLE1BQU10QixhQUF4QixFQUF1Q3NCLE1BQU1FLGFBQTdDLEVBQTRERixNQUFNcEIsUUFBbEUsRUFBNEUsWUFBQSxDQUFhLENBQXpGO0FBQ0Q7QUFDRixLQUpEO0FBTUQ7QUFSRGUsUUFBQUMsU0FBQSxHQUFBQSxTQUFBIiwiZmlsZSI6Im1hdGNoL2luZGV4d29yZHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBJTWF0Y2ggPSByZXF1aXJlKFwiLi9pZm1hdGNoXCIpO1xudmFyIHBnID0gcmVxdWlyZShcInBnXCIpO1xudmFyIGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xudmFyIGRlYnVnbG9nID0gZGVidWcoJ2luZGV4d29yZHMnKTtcbnZhciBjb2x1bW5zID0gWydsb3dlcmNhc2V3b3JkJywgJ21hdGNoZWRzdHJpbmcnLCAnY2F0ZWdvcnknXTtcbmZ1bmN0aW9uIGluc2VydFdvcmQoZGJ1cmwsIGxvd2VyY2FzZXdvcmQsIG1hdGNoZWRzdHJpbmcsIGNhdGVnb3J5LCBjYWxsYmFjaykge1xuICAgIHBnLmNvbm5lY3QoZGJ1cmwsIGZ1bmN0aW9uIChlcnIsIGNsaWVudCwgcGdEb25lKSB7XG4gICAgICAgIHZhciBvRW50cnkgPSB7XG4gICAgICAgICAgICBtYXRjaGVkc3RyaW5nOiBtYXRjaGVkc3RyaW5nLFxuICAgICAgICAgICAgbG93ZXJjYXNld29yZDogbG93ZXJjYXNld29yZCxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAvLyBmYWlsZWQgdG8gYWNxdWlyZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvL2xvZ2dlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBkZWJ1Z2xvZygnRXJyb3IgY29ubmVjdGluZyB0byBkYicgKyBlcnIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IFwiSU5TRVJUIElOVE8gd29yZHMgKFwiICsgY29sdW1ucy5qb2luKFwiLFwiKSArIFwiKSBcIiArXG4gICAgICAgICAgICAgICAgLy8gICAoY29udmlkLCBzZXNzaW9uaWQsIHVzZXIsIG1lc3NhZ2UsIHJlc3BvbnNlLCBtZXRhKSBgICtcbiAgICAgICAgICAgICAgICBcIlZBTFVFUyAoIFwiICtcbiAgICAgICAgICAgICAgICAvLyAkMSwgJDIsIC4uLlxuICAgICAgICAgICAgICAgIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChvLCBpSW5kZXgpIHsgcmV0dXJuIFwiJFwiICsgKGlJbmRleCArIDEpOyB9KS5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBjb2x1bW5zLm1hcChmdW5jdGlvbiAoc0NvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvRW50cnlbc0NvbF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vICBbbGV2ZWwsIG1zZywgbWV0YSBpbnN0YW5jZW9mIEFycmF5ID8gSlNPTi5zdHJpbmdpZnkobWV0YSkgOiBtZXRhXSxcbiAgICAgICAgICAgIGNsaWVudC5xdWVyeShxdWVyeSwgdmFsdWVzLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBwZ0RvbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnbG9nKCdFcnJvciBpbnNlcnRpbmcgcmVjb3JkIGludG8gZGIgJyArIGVyciArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICBsb2dnZXIuZW1pdCgnbG9nZ2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmluc2VydFdvcmQgPSBpbnNlcnRXb3JkO1xuZnVuY3Rpb24gZHVtcFdvcmRzKGRidXJsLCBtb2RlbCkge1xuICAgIC8vIG1vdmVcbiAgICBtb2RlbC5tUnVsZXMuZm9yRWFjaChmdW5jdGlvbiAobVJ1bGUpIHtcbiAgICAgICAgaWYgKG1SdWxlLnR5cGUgPT09IDAgLyogV09SRCAqLykge1xuICAgICAgICAgICAgaW5zZXJ0V29yZChkYnVybCwgbVJ1bGUubG93ZXJjYXNld29yZCwgbVJ1bGUubWF0Y2hlZFN0cmluZywgbVJ1bGUuY2F0ZWdvcnksIGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZHVtcFdvcmRzID0gZHVtcFdvcmRzO1xuIiwiXG5cblxuaW1wb3J0ICogYXMgSU1hdGNoIGZyb20gJy4vaWZtYXRjaCc7XG5pbXBvcnQgKiBhcyBwZyBmcm9tICdwZyc7XG5pbXBvcnQgKiBhcyBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbmNvbnN0IGRlYnVnbG9nID0gZGVidWcoJ2luZGV4d29yZHMnKTtcblxudmFyIGNvbHVtbnMgPSBbJ2xvd2VyY2FzZXdvcmQnLCAnbWF0Y2hlZHN0cmluZycsICdjYXRlZ29yeSddO1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydFdvcmQoZGJ1cmwgOiBzdHJpbmcsbG93ZXJjYXNld29yZCA6IHN0cmluZywgbWF0Y2hlZHN0cmluZyA6IHN0cmluZywgY2F0ZWdvcnk6IHN0cmluZywgY2FsbGJhY2sgOiAoZXJyOiBFcnJvciwgcmVzPyA6IGJvb2xlYW4pID0+IHZvaWQgKSB7XG4gIHBnLmNvbm5lY3QoZGJ1cmwsIChlcnIsIGNsaWVudCA6IHBnLkNsaWVudCwgcGdEb25lKSA9PiB7XG4gICAgICB2YXIgb0VudHJ5ID0gIHtcbiAgICAgICAgbWF0Y2hlZHN0cmluZyA6IG1hdGNoZWRzdHJpbmcsXG4gICAgICAgIGxvd2VyY2FzZXdvcmQgOiBsb3dlcmNhc2V3b3JkLFxuICAgICAgICBjYXRlZ29yeSA6IGNhdGVnb3J5XG4gICAgICB9XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIGZhaWxlZCB0byBhY3F1aXJlIGNvbm5lY3Rpb25cbiAgICAgICAgLy9sb2dnZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBkZWJ1Z2xvZygnRXJyb3IgY29ubmVjdGluZyB0byBkYicgKyBlcnIpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID1gSU5TRVJUIElOVE8gd29yZHMgKGAgKyBjb2x1bW5zLmpvaW4oXCIsXCIpICsgXCIpIFwiICtcbiAgICAgICAgLy8gICAoY29udmlkLCBzZXNzaW9uaWQsIHVzZXIsIG1lc3NhZ2UsIHJlc3BvbnNlLCBtZXRhKSBgICtcbiAgICAgICAgXCJWQUxVRVMgKCBcIiAgK1xuICAgICAgICAvLyAkMSwgJDIsIC4uLlxuICAgICAgICAgY29sdW1ucy5tYXAoZnVuY3Rpb24obyxpSW5kZXgpIHsgcmV0dXJuIFwiJFwiICsgKGlJbmRleCsxKTsgfSkuam9pbihcIiwgXCIpICsgXCIpXCI7XG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IGNvbHVtbnMubWFwKGZ1bmN0aW9uKHNDb2wpIHtcbiAgICAgICAgICAgICByZXR1cm4gb0VudHJ5W3NDb2xdO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgLy8gIFtsZXZlbCwgbXNnLCBtZXRhIGluc3RhbmNlb2YgQXJyYXkgPyBKU09OLnN0cmluZ2lmeShtZXRhKSA6IG1ldGFdLFxuICAgICAgICBjbGllbnQucXVlcnkocXVlcnksdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBwZ0RvbmUoKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAvLyBsb2dnZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgIGRlYnVnbG9nKCdFcnJvciBpbnNlcnRpbmcgcmVjb3JkIGludG8gZGIgJyArIGVyciArICdcXG4nICtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gIGxvZ2dlci5lbWl0KCdsb2dnZWQnKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkdW1wV29yZHMoZGJ1cmwgOiBzdHJpbmcsICBtb2RlbDogSU1hdGNoLklNb2RlbHMpIHtcbiAgLy8gbW92ZVxuICBtb2RlbC5tUnVsZXMuZm9yRWFjaChmdW5jdGlvbihtUnVsZSkge1xuICAgIGlmKG1SdWxlLnR5cGUgPT09IElNYXRjaC5FbnVtUnVsZVR5cGUuV09SRCkge1xuICAgICAgaW5zZXJ0V29yZChkYnVybCwgbVJ1bGUubG93ZXJjYXNld29yZCwgbVJ1bGUubWF0Y2hlZFN0cmluZywgbVJ1bGUuY2F0ZWdvcnksIGZ1bmN0aW9uKCkge30pO1xuICAgIH1cbiAgfSk7XG5cbn0iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
